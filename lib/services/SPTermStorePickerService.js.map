{"version":3,"sources":["services/SPTermStorePickerService.ts"],"names":[],"mappings":"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","file":"services/SPTermStorePickerService.js","sourcesContent":["/**\r\n * DISCLAIMER\r\n *\r\n * As there is not yet an OData end-point for managed metadata, this service makes use of the ProcessQuery end-points.\r\n * The service will get updated once the APIs are in place for managing managed metadata.\r\n */\r\n\r\nimport { SPHttpClient, SPHttpClientResponse, ISPHttpClientOptions } from '@microsoft/sp-http';\r\nimport { Environment, EnvironmentType } from '@microsoft/sp-core-library';\r\nimport { IWebPartContext } from '@microsoft/sp-webpart-base';\r\nimport { ITaxonomyPickerProps } from '../controls/taxonomyPicker/ITaxonomyPicker';\r\nimport { IPickerTerm } from '../controls/taxonomyPicker/ITermPicker';\r\nimport { ITermStore, ITerms, ITerm, IGroup, ITermSet, ISuggestTerm } from './ISPTermStorePickerService';\r\nimport SPTermStoreMockHttpClient from './SPTermStorePickerMockService';\r\nimport { findIndex } from '@microsoft/sp-lodash-subset';\r\nimport { ExtensionContext } from '@microsoft/sp-extension-base';\r\nimport { EmptyGuid } from '../common/Constants';\r\n\r\n\r\n/**\r\n * Service implementation to manage term stores in SharePoint\r\n */\r\nexport default class SPTermStorePickerService {\r\n  private taxonomySession: string;\r\n  private formDigest: string;\r\n  private clientServiceUrl: string;\r\n  private suggestionServiceUrl: string;\r\n\r\n  /**\r\n   * Service constructor\r\n   */\r\n  constructor(private props: ITaxonomyPickerProps, private context: IWebPartContext | ExtensionContext) {\r\n    if (Environment.type !== EnvironmentType.Local) {\r\n      {\r\n        this.clientServiceUrl = this.context.pageContext.web.absoluteUrl + '/_vti_bin/client.svc/ProcessQuery';\r\n        this.suggestionServiceUrl = this.context.pageContext.web.absoluteUrl + \t\"/_vti_bin/TaxonomyInternalService.json/GetSuggestions\";\r\n      }\r\n    }\r\n  }\r\n\r\n  public async getTermLabels(termId: string): Promise<string[]> {\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      // If the running environment is local, load the data from the mock\r\n      return null;\r\n    }\r\n\r\n    let result = null;\r\n    try {\r\n      const data = `<Request AddExpandoFieldTypeSuffix=\"true\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\".NET Library\" xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\"><Actions><ObjectPath Id=\"8\" ObjectPathId=\"7\" /><ObjectIdentityQuery Id=\"9\" ObjectPathId=\"7\" /><ObjectPath Id=\"11\" ObjectPathId=\"10\" /><ObjectIdentityQuery Id=\"12\" ObjectPathId=\"10\" /><ObjectPath Id=\"14\" ObjectPathId=\"13\" /><ObjectIdentityQuery Id=\"15\" ObjectPathId=\"13\" /><Query Id=\"16\" ObjectPathId=\"13\"><Query SelectAllProperties=\"false\"><Properties><Property Name=\"Labels\" SelectAll=\"true\"><Query SelectAllProperties=\"false\"><Properties /></Query></Property></Properties></Query></Query></Actions><ObjectPaths><StaticMethod Id=\"7\" Name=\"GetTaxonomySession\" TypeId=\"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\" /><Method Id=\"10\" ParentId=\"7\" Name=\"GetDefaultKeywordsTermStore\" /><Method Id=\"13\" ParentId=\"10\" Name=\"GetTerm\"><Parameters><Parameter Type=\"Guid\">${termId}</Parameter></Parameters></Method></ObjectPaths></Request>`;\r\n\r\n      const reqHeaders = new Headers();\r\n      reqHeaders.append(\"accept\", \"application/json\");\r\n      reqHeaders.append(\"content-type\", \"application/xml\");\r\n\r\n      const httpPostOptions: ISPHttpClientOptions = {\r\n        headers: reqHeaders,\r\n        body: data\r\n      };\r\n\r\n      const callResult = await this.context.spHttpClient.post(this.clientServiceUrl, SPHttpClient.configurations.v1, httpPostOptions);\r\n      const jsonResult = await callResult.json();\r\n\r\n      let node = jsonResult.find(x => x._ObjectType_ == \"SP.Taxonomy.Term\");\r\n      if (node && node.Labels && node.Labels._Child_Items_) {\r\n        result = node.Labels._Child_Items_.map(termLabel => termLabel.Value);\r\n      }\r\n    } catch (error) {\r\n      result = null;\r\n      console.log(error.message);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets the collection of term stores in the current SharePoint env\r\n   */\r\n  public getTermStores(): Promise<ITermStore[]> {\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      // If the running environment is local, load the data from the mock\r\n      return this.getTermStoresFromMock();\r\n    } else {\r\n      // Retrieve the term store name, groups, and term sets\r\n      const data = '<Request AddExpandoFieldTypeSuffix=\"true\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\".NET Library\" xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\"><Actions><ObjectPath Id=\"2\" ObjectPathId=\"1\" /><ObjectIdentityQuery Id=\"3\" ObjectPathId=\"1\" /><ObjectPath Id=\"5\" ObjectPathId=\"4\" /><ObjectIdentityQuery Id=\"6\" ObjectPathId=\"4\" /><Query Id=\"7\" ObjectPathId=\"4\"><Query SelectAllProperties=\"false\"><Properties><Property Name=\"Id\" ScalarProperty=\"true\" /><Property Name=\"Name\" ScalarProperty=\"true\" /><Property Name=\"Groups\"><Query SelectAllProperties=\"false\"><Properties /></Query><ChildItemQuery SelectAllProperties=\"false\"><Properties><Property Name=\"Name\" ScalarProperty=\"true\" /><Property Name=\"Id\" ScalarProperty=\"true\" /><Property Name=\"IsSystemGroup\" ScalarProperty=\"true\" /><Property Name=\"TermSets\"><Query SelectAllProperties=\"false\"><Properties /></Query><ChildItemQuery SelectAllProperties=\"false\"><Properties><Property Name=\"Name\" ScalarProperty=\"true\" /><Property Name=\"Id\" ScalarProperty=\"true\" /><Property Name=\"Description\" ScalarProperty=\"true\" /><Property Name=\"Names\" ScalarProperty=\"true\" /></Properties></ChildItemQuery></Property></Properties></ChildItemQuery></Property></Properties></Query></Query></Actions><ObjectPaths><StaticMethod Id=\"1\" Name=\"GetTaxonomySession\" TypeId=\"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\" /><Method Id=\"4\" ParentId=\"1\" Name=\"GetDefaultSiteCollectionTermStore\" /></ObjectPaths></Request>';\r\n\r\n      const reqHeaders = new Headers();\r\n      reqHeaders.append(\"accept\", \"application/json\");\r\n      reqHeaders.append(\"content-type\", \"application/xml\");\r\n\r\n      const httpPostOptions: ISPHttpClientOptions = {\r\n        headers: reqHeaders,\r\n        body: data\r\n      };\r\n\r\n      return this.context.spHttpClient.post(this.clientServiceUrl, SPHttpClient.configurations.v1, httpPostOptions).then((serviceResponse: SPHttpClientResponse) => {\r\n        return serviceResponse.json().then((serviceJSONResponse: any) => {\r\n          // Construct results\r\n          let termStoreResult: ITermStore[] = serviceJSONResponse.filter((r: { [x: string]: string; }) => !!r && r['_ObjectType_'] === 'SP.Taxonomy.TermStore');\r\n          // Check if term store was retrieved\r\n          if (termStoreResult.length > 0) {\r\n            // Check if the termstore needs to be filtered or limited\r\n            if (this.props.termsetNameOrID) {\r\n              return termStoreResult.map(termstore => {\r\n                let termGroups = termstore.Groups._Child_Items_;\r\n\r\n                // Check if the groups have to be limited to a specific term set\r\n                if (this.props.termsetNameOrID) {\r\n                  const termsetNameOrId = this.props.termsetNameOrID;\r\n                  termGroups = termGroups.map((group: IGroup) => {\r\n                    group.TermSets._Child_Items_ = group.TermSets._Child_Items_.filter((termSet: ITermSet) => termSet.Name === termsetNameOrId || this.cleanGuid(termSet.Id).toLowerCase() === this.cleanGuid(termsetNameOrId).toLowerCase());\r\n                    return group;\r\n                  });\r\n                }\r\n\r\n                // Filter out all systen groups\r\n                termGroups = termGroups.filter(group => !group.IsSystemGroup);\r\n\r\n                // Filter out empty groups\r\n                termGroups = termGroups.filter((group: IGroup) => group.TermSets._Child_Items_.length > 0);\r\n\r\n                // Map the new groups\r\n                termstore.Groups._Child_Items_ = termGroups;\r\n                return termstore;\r\n              });\r\n            }\r\n\r\n            // Return the term store results\r\n            return termStoreResult;\r\n          }\r\n          return [];\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current term set\r\n   */\r\n  public async getTermSet(): Promise<ITermSet> {\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      const termSetInfo = await SPTermStoreMockHttpClient.getAllTerms();\r\n      return termSetInfo;\r\n    } else {\r\n      const termStore = await this.getTermStores();\r\n      return this.getTermSetId(termStore, this.props.termsetNameOrID);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve all terms for the given term set\r\n   * @param termset\r\n   */\r\n  public async getAllTerms(termset: string, hideDeprecatedTags?: boolean, hideTagsNotAvailableForTagging?: boolean): Promise<ITermSet> {\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      // If the running environment is local, load the data from the mock\r\n      return this.getAllMockTerms();\r\n    } else {\r\n      let termsetId: string = termset;\r\n      // Check if the provided term set property is a GUID or string\r\n      if (!this.isGuid(termset)) {\r\n        // Fetch the term store information\r\n        const termStore = await this.getTermStores();\r\n        // Get the ID of the provided term set name\r\n        const crntTermSet = this.getTermSetId(termStore, termset);\r\n        if (crntTermSet) {\r\n          termsetId = this.cleanGuid(crntTermSet.Id);\r\n        } else {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      let childTerms = this.getTermsById(termsetId);\r\n\r\n      if (childTerms) {\r\n        return childTerms;\r\n      }\r\n\r\n      // Request body to retrieve all terms for the given term set\r\n      const data = `<Request xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\"Javascript Library\"><Actions><ObjectPath Id=\"1\" ObjectPathId=\"0\" /><ObjectIdentityQuery Id=\"2\" ObjectPathId=\"0\" /><ObjectPath Id=\"4\" ObjectPathId=\"3\" /><ObjectIdentityQuery Id=\"5\" ObjectPathId=\"3\" /><ObjectPath Id=\"7\" ObjectPathId=\"6\" /><ObjectIdentityQuery Id=\"8\" ObjectPathId=\"6\" /><ObjectPath Id=\"10\" ObjectPathId=\"9\" /><Query Id=\"11\" ObjectPathId=\"6\"><Query SelectAllProperties=\"true\"><Properties /></Query></Query><Query Id=\"12\" ObjectPathId=\"9\"><Query SelectAllProperties=\"false\"><Properties /></Query><ChildItemQuery SelectAllProperties=\"false\"><Properties><Property Name=\"IsRoot\" SelectAll=\"true\" /><Property Name=\"Labels\" SelectAll=\"true\" /><Property Name=\"TermsCount\" SelectAll=\"true\" /><Property Name=\"CustomSortOrder\" SelectAll=\"true\" /><Property Name=\"Id\" SelectAll=\"true\" /><Property Name=\"Name\" SelectAll=\"true\" /><Property Name=\"PathOfTerm\" SelectAll=\"true\" /><Property Name=\"Parent\" SelectAll=\"true\" /><Property Name=\"LocalCustomProperties\" SelectAll=\"true\" /><Property Name=\"IsDeprecated\" ScalarProperty=\"true\" /><Property Name=\"IsAvailableForTagging\" ScalarProperty=\"true\" /></Properties></ChildItemQuery></Query></Actions><ObjectPaths><StaticMethod Id=\"0\" Name=\"GetTaxonomySession\" TypeId=\"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\" /><Method Id=\"3\" ParentId=\"0\" Name=\"GetDefaultKeywordsTermStore\" /><Method Id=\"6\" ParentId=\"3\" Name=\"GetTermSet\"><Parameters><Parameter Type=\"Guid\">${termsetId}</Parameter></Parameters></Method><Method Id=\"9\" ParentId=\"6\" Name=\"GetAllTerms\" /></ObjectPaths></Request>`;\r\n\r\n\r\n      const reqHeaders = new Headers();\r\n      reqHeaders.append(\"accept\", \"application/json\");\r\n      reqHeaders.append(\"content-type\", \"application/xml\");\r\n\r\n      const httpPostOptions: ISPHttpClientOptions = {\r\n        headers: reqHeaders,\r\n        body: data\r\n      };\r\n\r\n      return this.context.spHttpClient.post(this.clientServiceUrl, SPHttpClient.configurations.v1, httpPostOptions).then((serviceResponse: SPHttpClientResponse) => {\r\n        return serviceResponse.json().then((serviceJSONResponse: any) => {\r\n          const termStoreResultTermSets: ITermSet[] = serviceJSONResponse.filter((r: { [x: string]: string; }) => r['_ObjectType_'] === 'SP.Taxonomy.TermSet');\r\n\r\n          if (termStoreResultTermSets.length > 0) {\r\n            var termStoreResultTermSet = termStoreResultTermSets[0];\r\n            termStoreResultTermSet.Terms = [];\r\n            // Retrieve the term collection results\r\n            const termStoreResultTerms: ITerms[] = serviceJSONResponse.filter((r: { [x: string]: string; }) => r['_ObjectType_'] === 'SP.Taxonomy.TermCollection');\r\n            if (termStoreResultTerms.length > 0) {\r\n              // Retrieve all terms\r\n              let terms = termStoreResultTerms[0]._Child_Items_;\r\n\r\n              if (hideDeprecatedTags === true) {\r\n                terms = terms.filter(d => d[\"IsDeprecated\"] === false);\r\n              }\r\n\r\n              if (hideTagsNotAvailableForTagging === true) {\r\n                terms = terms.filter(d => d[\"IsAvailableForTagging\"] === true);\r\n              }\r\n\r\n              // Clean the term ID and specify the path depth\r\n              terms = terms.map(term => {\r\n                if (term.IsRoot) {\r\n                  term.CustomSortOrderIndex = (termStoreResultTermSet.CustomSortOrder) ? termStoreResultTermSet.CustomSortOrder.split(\":\").indexOf(this.cleanGuid(term.Id)) : -1;\r\n                } else {\r\n                  term.CustomSortOrderIndex = (term[\"Parent\"].CustomSortOrder) ? term[\"Parent\"].CustomSortOrder.split(\":\").indexOf(this.cleanGuid(term.Id)) : -1;\r\n                }\r\n                term.Id = this.cleanGuid(term.Id);\r\n                term['PathDepth'] = term.PathOfTerm.split(';').length;\r\n                term.TermSet = { Id: this.cleanGuid(termStoreResultTermSet.Id), Name: termStoreResultTermSet.Name };\r\n                if (term[\"Parent\"]) {\r\n                  term.ParentId = this.cleanGuid(term[\"Parent\"].Id);\r\n                }\r\n                return term;\r\n              });\r\n              // Check if the term set was not empty\r\n              if (terms.length > 0) {\r\n                // Sort the terms by PathOfTerm and their depth\r\n                terms = this.sortTerms(terms);\r\n                termStoreResultTermSet.Terms = terms;\r\n              }\r\n            }\r\n\r\n            sessionStorage.setItem(termsetId, JSON.stringify(termStoreResultTermSet));\r\n            return termStoreResultTermSet;\r\n          }\r\n          return null;\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the term set ID by its name\r\n   * @param termstore\r\n   * @param termset\r\n   */\r\n  private getTermSetId(termstore: ITermStore[], termsetName: string): ITermSet {\r\n    if (termstore && termstore.length > 0 && termsetName) {\r\n      // Get the first term store\r\n      const ts = termstore[0];\r\n      // Check if the term store contains groups\r\n      if (ts.Groups && ts.Groups._Child_Items_) {\r\n        for (const group of ts.Groups._Child_Items_) {\r\n          // Check if the group contains term sets\r\n          if (group.TermSets && group.TermSets._Child_Items_) {\r\n            for (const termSet of group.TermSets._Child_Items_) {\r\n              // Check if the term set is found\r\n              if (termSet.Name === termsetName) {\r\n                return termSet;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n\r\n  /**\r\n   * Retrieve all terms that starts with the searchText\r\n   * @param searchText\r\n   */\r\n  public searchTermsByName(searchText: string): Promise<IPickerTerm[]> {\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      // If the running environment is local, load the data from the mock\r\n      return SPTermStoreMockHttpClient.searchTermsByName(searchText);\r\n    } else {\r\n      return this.searchTermsByTermSet(searchText);\r\n    }\r\n  }\r\n\r\n  private getTermsById(termId) {\r\n    var terms = sessionStorage.getItem(termId);\r\n    if (terms)\r\n      return JSON.parse(terms);\r\n    else\r\n      return null;\r\n  }\r\n\r\n  private searchTermsBySearchText(terms, searchText) {\r\n    if (terms) {\r\n      return terms.filter((t) => { return t.name.toLowerCase().indexOf(searchText.toLowerCase()) > -1; });\r\n    }\r\n    else\r\n      return [];\r\n  }\r\n\r\n  public async searchTermsByTermId(searchText: string, termId: string): Promise<IPickerTerm[]> {\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      // If the running environment is local, load the data from the mock\r\n      return SPTermStoreMockHttpClient.searchTermsByName(searchText);\r\n    } else {\r\n      var childTerms = this.getTermsById(termId);\r\n      if (childTerms) {\r\n        return this.searchTermsBySearchText(childTerms, searchText);\r\n      }\r\n      else {\r\n        const {\r\n          termsetNameOrID,\r\n          hideDeprecatedTags,\r\n          hideTagsNotAvailableForTagging\r\n        } = this.props;\r\n\r\n        const terms = await this.getAllTermsByAnchorId(\r\n          termsetNameOrID,\r\n          termId,\r\n          hideDeprecatedTags,\r\n          hideTagsNotAvailableForTagging);\r\n\r\n        if (terms) {\r\n          return this.searchTermsBySearchText(terms, searchText);\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve all terms for the given term set and anchorId\r\n   */\r\n  public async getAllTermsByAnchorId(termsetNameOrID: string, anchorId: string, hideDeprecatedTags?: boolean, hideTagsNotAvailableForTagging?: boolean): Promise<IPickerTerm[]> {\r\n\r\n    let returnTerms: IPickerTerm[] = [];\r\n\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      // If the running environment is local, load the data from the mock\r\n      let terms = await this.getAllMockTermsByAnchor();\r\n      terms.forEach(term => {\r\n        returnTerms.push(this.convertTermToPickerTerm(term));\r\n      });\r\n    } else {\r\n      const childTerms = this.getTermsById(anchorId);\r\n      if (childTerms) {\r\n        return childTerms;\r\n      }\r\n\r\n      let termSet = await this.getAllTerms(termsetNameOrID, hideDeprecatedTags, hideTagsNotAvailableForTagging);\r\n      let terms = termSet.Terms;\r\n      if (anchorId) {\r\n        const anchorTerm = terms.filter(t => t.Id.toLowerCase() === anchorId.toLowerCase()).shift();\r\n        if (anchorTerm) {\r\n          // Append ';' separator, as a suffix to anchor term path.\r\n          const anchorTermPath = `${anchorTerm.PathOfTerm};`;\r\n          const anchorTerms: ITerm[] = terms.filter(t => t.PathOfTerm.substring(0, anchorTermPath.length) === anchorTermPath && t.Id !== anchorTerm.Id);\r\n\r\n          anchorTerms.forEach(term => {\r\n            returnTerms.push(this.convertTermToPickerTerm(term));\r\n          });\r\n\r\n          sessionStorage.setItem(anchorId, JSON.stringify(returnTerms));\r\n        }\r\n      } else {\r\n        terms.forEach(term => {\r\n          returnTerms.push(this.convertTermToPickerTerm(term));\r\n        });\r\n      }\r\n    }\r\n\r\n    return returnTerms;\r\n  }\r\n\r\n  /**\r\n     * Searches terms for the given term set\r\n     * @param searchText\r\n     * @param termsetId\r\n     */\r\n  private searchTermsByTermSet(searchText: string): Promise<IPickerTerm[]> {\r\n    if (Environment.type === EnvironmentType.Local) {\r\n      // If the running environment is local, load the data from the mock\r\n      return SPTermStoreMockHttpClient.searchTermsByName(searchText);\r\n    } else {\r\n      return new Promise<IPickerTerm[]>(resolve => {\r\n        this.getTermStores().then(termStore => {\r\n          let TermSetId = this.props.termsetNameOrID;\r\n          if (!this.isGuid(TermSetId)) {\r\n            // Get the ID of the provided term set name\r\n            const crntTermSet = this.getTermSetId(termStore, TermSetId);\r\n            if (crntTermSet) {\r\n              TermSetId = this.cleanGuid(crntTermSet.Id);\r\n            } else {\r\n              resolve(null);\r\n              return;\r\n            }\r\n          }\r\n          if (termStore === undefined || termStore.length  === 0) {\r\n            resolve(null);\r\n            return;\r\n          }\r\n\r\n          let data = {\r\n            start: searchText,\r\n            lcid : this.context.pageContext.web.language, // TODO : get the user's navitation LCID. Here it's the default web language LCID\r\n            sspList: this.cleanGuid(termStore[0].Id),\r\n            termSetList: TermSetId,\r\n            anchorId: this.props.anchorId ? this.props.anchorId : EmptyGuid,\r\n            isSpanTermStores: false,\r\n            isSpanTermSets: false,\r\n            isIncludeUnavailable: this.props.hideTagsNotAvailableForTagging === true,\r\n            isIncludeDeprecated: this.props.hideDeprecatedTags === true,\r\n            isAddTerms: false,\r\n            isIncludePathData: false,\r\n            excludeKeyword: false,\r\n            excludedTermset: EmptyGuid\r\n          };\r\n\r\n          const reqHeaders = new Headers();\r\n          reqHeaders.append(\"accept\", \"application/json\");\r\n          reqHeaders.append(\"content-type\", \"application/json\");\r\n\r\n          const httpPostOptions: ISPHttpClientOptions = {\r\n            headers: reqHeaders,\r\n            body: JSON.stringify(data)\r\n          };\r\n\r\n\r\n          return this.context.spHttpClient.post(this.suggestionServiceUrl, SPHttpClient.configurations.v1, httpPostOptions).then((serviceResponse: SPHttpClientResponse) => {\r\n            return serviceResponse.json().then((serviceJSONResponse: any) => {\r\n              const groups = serviceJSONResponse.d.Groups;\r\n              if (groups && groups.length > 0) {\r\n                // Retrieve the term collection results\r\n                const terms: ISuggestTerm[] = groups[0].Suggestions;\r\n                if (terms.length > 0) {\r\n                  // Retrieve all terms\r\n\r\n                  let returnTerms: IPickerTerm[] = terms.map((term: ISuggestTerm) => this.convertSuggestTermToPickerTerm(term));\r\n                  resolve(returnTerms);\r\n                  return;\r\n                }\r\n\r\n              }\r\n\r\n              resolve([]);\r\n            });\r\n          });\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  private isGuid(strGuid: string): boolean {\r\n    return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(strGuid);\r\n  }\r\n\r\n  /**\r\n   * Sorting terms based on their path and depth\r\n   *\r\n   * @param terms\r\n   */\r\n  private sortTerms(terms: ITerm[]) {\r\n    // Start sorting by depth\r\n    let newTermsOrder: ITerm[] = [];\r\n    let itemsToSort = true;\r\n    let pathLevel = 1;\r\n    while (itemsToSort) {\r\n      // Get terms for the current level\r\n      let crntTerms = terms.filter(term => term.PathDepth === pathLevel);\r\n      if (crntTerms && crntTerms.length > 0) {\r\n        crntTerms = crntTerms.sort(this.sortTermByPath);\r\n\r\n        if (pathLevel !== 1) {\r\n          crntTerms = crntTerms.reverse();\r\n          for (const crntTerm of crntTerms) {\r\n            const pathElms = crntTerm.PathOfTerm.split(\";\");\r\n            // Last item is not needed for parent path\r\n            pathElms.pop();\r\n            // Find the parent item and add the new item\r\n            const idx = findIndex(newTermsOrder, term => term.PathOfTerm === pathElms.join(\";\"));\r\n            if (idx !== -1) {\r\n              newTermsOrder.splice(idx + 1, 0, crntTerm);\r\n            } else {\r\n              // Push the item at the end if the parent couldn't be found\r\n              newTermsOrder.push(crntTerm);\r\n            }\r\n          }\r\n        } else {\r\n          newTermsOrder = crntTerms;\r\n        }\r\n\r\n        ++pathLevel;\r\n      } else {\r\n        itemsToSort = false;\r\n      }\r\n    }\r\n    return newTermsOrder;\r\n  }\r\n\r\n  /**\r\n   * Sort the terms by their path\r\n   *\r\n   * @param a term 2\r\n   * @param b term 2\r\n   */\r\n  private sortTermByPath(a: ITerm, b: ITerm) {\r\n    if (a.CustomSortOrderIndex === -1) {\r\n      if (a.PathOfTerm.toLowerCase() < b.PathOfTerm.toLowerCase()) {\r\n        return -1;\r\n      }\r\n      if (a.PathOfTerm.toLowerCase() > b.PathOfTerm.toLowerCase()) {\r\n        return 1;\r\n      }\r\n      return 0;\r\n    } else {\r\n      if (a.CustomSortOrderIndex < b.CustomSortOrderIndex) {\r\n        return -1;\r\n      }\r\n      if (a.CustomSortOrderIndex > b.CustomSortOrderIndex) {\r\n        return 1;\r\n      }\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean the Guid from the Web Service response\r\n   * @param guid\r\n   */\r\n  public cleanGuid(guid: string): string {\r\n    if (guid !== undefined) {\r\n      return guid.replace('/Guid(', '').replace('/', '').replace(')', '');\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns 3 fake SharePoint lists for the Mock mode\r\n   */\r\n  private getTermStoresFromMock(): Promise<ITermStore[]> {\r\n    return SPTermStoreMockHttpClient.getTermStores(this.context.pageContext.web.absoluteUrl).then((data) => {\r\n      return data;\r\n    }) as Promise<ITermStore[]>;\r\n  }\r\n\r\n  /**\r\n   * Returns 3 fake SharePoint lists for the Mock mode\r\n   */\r\n  private getAllMockTerms(): Promise<ITermSet> {\r\n    return SPTermStoreMockHttpClient.getAllTerms().then((data) => {\r\n      return data;\r\n    }) as Promise<ITermSet>;\r\n  }\r\n\r\n  /**\r\n   * Returns 3 fake SharePoint lists for the Mock mode\r\n   */\r\n  private getAllMockTermsByAnchor(): Promise<ITerm[]> {\r\n    return SPTermStoreMockHttpClient.getAllTermsByAnchorId().then((data) => {\r\n      return data;\r\n    }) as Promise<ITerm[]>;\r\n  }\r\n\r\n  private convertTermToPickerTerm(term: ITerm): IPickerTerm {\r\n    return {\r\n      key: this.cleanGuid(term.Id),\r\n      name: term.Name,\r\n      path: term.PathOfTerm,\r\n      termSet: this.cleanGuid(term.TermSet.Id),\r\n      termSetName: term.TermSet.Name\r\n    };\r\n  }\r\n\r\n  private convertSuggestTermToPickerTerm(term: ISuggestTerm): IPickerTerm {\r\n    let path: string = \"\";\r\n    let termSetName: string = \"\";\r\n    if (term.Paths && term.Paths.length > 0) {\r\n      const fullPath = term.Paths[0].replace(/^\\[/, \"\").replace(/\\]$/, \"\");\r\n      const fullPathParts = fullPath.split(\":\");\r\n      path = fullPathParts.join(\";\") + \";\" +  term.DefaultLabel;\r\n      termSetName = fullPathParts[0];\r\n    }\r\n    return {\r\n      key: this.cleanGuid(term.Id),\r\n      name: term.DefaultLabel,\r\n      path: path,\r\n      termSet: EmptyGuid, // TermSet Guid is not given with suggestion\r\n      termSetName: termSetName\r\n    };\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}